<!DOCTYPE html>
<html>
<head>
    <title>Golf gelinding Gameplay</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<include expiration='7d' path='*.css'></include>
<include expiration='7d' path='*.js'></include>
<include expiration='7d' path='*.woff2'></include>
<include expiration='3d' path='*.gif'></include>
<include expiration='3d' path='*.jpeg'></include>
<include expiration='3d' path='*.jpg'></include>
<include expiration='3d' path='*.png'></include>
<include expiration='3d' path='*.webp'></include>
	<link href="//fonts.gstatic.com" rel="preconnect"/>
	<link href="//ajax.googleapis.com" rel="preconnect"/>
	<link href="//cdn.jsdelivr.net" rel="preconnect"/>
	<link href="//cdnjs.cloudflare.com" rel="preconnect"/>
	<link href="//res.cloudinary.com" rel="preconnect"/>
    <style>
        body, html {
            margin: 0;
            height: 100%;
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        @font-face {
            font-family: Quicksand;
            font-style: normal;
            font-weight: 400;
            font-display: swap;
            src: url(https://fonts.gstatic.com/s/quicksand/v24/6xK-dSZaM9iE8KbpRA_LJ3z8mH9BOJvgkP8o58a-xDwxUD2GFw.woff) format('woff');
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
        }
        
        body, html {
            font-family: Quicksand;
        }
        
        .mobile-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 1000;
            opacity: 0.7;
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
        }
        
        .control-btn:active {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(0.95);
        }
        
        .volume-control {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .volume-control label {
            color: white;
            font-size: 14px;
        }
        
        .volume-slider {
            width: 100px;
            height: 6px;
            background: #ddd;
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #5D5CDE;
            cursor: pointer;
            border-radius: 50%;
        }
        
        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #5D5CDE;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        
        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
            }
            
            #scoreText {
                font-size: 3em !important;
                left: 10px !important;
            }
            
            .volume-control {
                top: 10px;
                right: 10px;
                padding: 8px;
            }
            
            .volume-control label {
                font-size: 12px;
            }
            
            .volume-slider {
                width: 80px;
            }
        }
        
        @media (min-width: 769px) {
            .mobile-controls {
                display: none;
            }
        }
        
        .instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            z-index: 1001;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            font-size: 18px;
        }
        
        @media (max-width: 768px) {
            .instructions {
                font-size: 14px;
                padding: 15px;
            }
        }
    </style>
</head>
<body oncontextmenu="return false">
    <img onclick="window.location.href='/'" width="80" style="position:fixed;z-index:9999999999999999!important;right:5px;bottom:15px;" src="https://res.cloudinary.com/dpoer5oaq/image/upload/v1630625180/276-2767433_back-button-white-png-transparent-png-removebg-preview_tjhw7y.png"/>
    
    <div id="instructions" class="instructions">
        <div>üéÆ HOW TO PLAY üéÆ</div>
        <div style="margin: 10px 0;">Desktop: Use Arrow Keys</div>
        <div>Mobile: Tap buttons or screen areas</div>
        <div style="margin-top: 15px; font-size: 14px;">Tap anywhere to start!</div>
    </div>
    
    <div class="volume-control">
        <label for="volumeSlider">üîä</label>
        <input type="range" id="volumeSlider" class="volume-slider" min="0" max="1" step="0.1" value="0.5">
    </div>
    
    <div id="TutContainer"></div>
    
    <div class="mobile-controls">
        <div class="control-btn" id="leftBtn">‚Üê</div>
        <div class="control-btn" id="jumpBtn">‚Üë</div>
        <div class="control-btn" id="rightBtn">‚Üí</div>
    </div>
    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js" defer="defer"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11" defer="defer"></script>
    <script type="module">
        import * as THREE from "https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.module.js" defer="defer";
        import { OrbitControls } from "OrbitControls.js" defer="defer";

        var sceneWidth, sceneHeight, camera, scene, renderer, dom, sun, ground, orbitControl, rollingGroundSphere, heroSphere, heroRollingSpeed, sphericalHelper, pathAngleValues, currentLane, clock, jumping, treesInPath, treesPool, particleGeometry, particles, scoreText, score, hasCollided;
        var rollingSpeed = 0.008;
        var worldRadius = 26;
        var heroRadius = 0.2;
        var heroBaseY = 1.8;
        var bounceValue = 0.1;
        var gravity = 0.005;
        var leftLane = -1;
        var rightLane = 1;
        var middleLane = 0;
        var treeReleaseInterval = 0.5;
        var lastTreeReleaseTime = 0;
        var particleCount = 20;
        var explosionPower = 1.06;
        var gameStarted = false;
        var backgroundMusic;

        function init() {
            try {
                createScene();
                setupAudio();
                setupMobileControls();
                setupTouchControls();
                update();
            } catch (error) {
                console.error("Error initializing game:", error);
            }
        }

        function setupAudio() {
            try {
                // Create audio element programmatically
                backgroundMusic = new Audio();
                backgroundMusic.loop = true;
                backgroundMusic.volume = 0.5;
                
                // Add audio sources
                backgroundMusic.src = 'music.ogg';
                
                const volumeSlider = document.getElementById('volumeSlider');
                volumeSlider.addEventListener('input', function() {
                    if (backgroundMusic) {
                        backgroundMusic.volume = this.value;
                    }
                });
            } catch (error) {
                console.log("Audio setup failed:", error);
            }
        }

        function startGame() {
            gameStarted = true;
            document.getElementById('instructions').style.display = 'none';
            
            // Start background music
            try {
                if (backgroundMusic) {
                    backgroundMusic.play().catch(e => {
                        console.log("Audio autoplay was prevented:", e);
                    });
                }
            } catch (error) {
                console.log("Failed to start audio:", error);
            }
        }

        function setupMobileControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const jumpBtn = document.getElementById('jumpBtn');

            leftBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!gameStarted) startGame();
                handleMove('left');
            });

            rightBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!gameStarted) startGame();
                handleMove('right');
            });

            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!gameStarted) startGame();
                handleMove('jump');
            });

            // Mouse events for desktop testing
            leftBtn.addEventListener('click', () => {
                if (!gameStarted) startGame();
                handleMove('left');
            });
            rightBtn.addEventListener('click', () => {
                if (!gameStarted) startGame();
                handleMove('right');
            });
            jumpBtn.addEventListener('click', () => {
                if (!gameStarted) startGame();
                handleMove('jump');
            });
        }

        function setupTouchControls() {
            let touchStartX = 0;
            let touchStartTime = 0;

            document.addEventListener('touchstart', (e) => {
                if (!gameStarted) {
                    startGame();
                    return;
                }
                
                touchStartX = e.touches[0].clientX;
                touchStartTime = Date.now();
            });

            document.addEventListener('touchend', (e) => {
                if (!gameStarted) return;
                
                const touchEndX = e.changedTouches[0].clientX;
                const touchDuration = Date.now() - touchStartTime;
                const touchDiff = touchEndX - touchStartX;
                const screenWidth = window.innerWidth;

                // Quick tap for jump
                if (touchDuration < 200 && Math.abs(touchDiff) < 50) {
                    handleMove('jump');
                    return;
                }

                // Swipe or tap in different screen areas
                if (touchEndX < screenWidth / 3) {
                    handleMove('left');
                } else if (touchEndX > (screenWidth * 2) / 3) {
                    handleMove('right');
                } else {
                    handleMove('jump');
                }
            });

            // Prevent default touch behaviors
            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
        }

        function handleMove(direction) {
            if (hasCollided) return;

            if (direction === 'left') {
                if (currentLane == middleLane) {
                    currentLane = leftLane;
                } else if (currentLane == rightLane) {
                    currentLane = middleLane;
                }
            } else if (direction === 'right') {
                if (currentLane == middleLane) {
                    currentLane = rightLane;
                } else if (currentLane == leftLane) {
                    currentLane = middleLane;
                }
            }

            if (direction === 'jump' || direction === 'left' || direction === 'right') {
                if (heroSphere.position.y <= heroBaseY + 0.1) {
                    bounceValue = 0.1;
                    jumping = true;
                }
            }
        }

        function createScene() {
            hasCollided = false;
            score = 0;
            treesInPath = [];
            treesPool = [];
            clock = new THREE.Clock();
            clock.start();

            heroRollingSpeed = rollingSpeed * worldRadius / heroRadius / 5;
            sphericalHelper = new THREE.Spherical();
            pathAngleValues = [1.52, 1.57, 1.62];

            sceneWidth = window.innerWidth;
            sceneHeight = window.innerHeight;
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xf0f8ff, 0.14);

            camera = new THREE.PerspectiveCamera(60, sceneWidth / sceneHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setClearColor(0xfff8dc, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setSize(sceneWidth, sceneHeight);

            dom = document.getElementById("TutContainer");
            dom.appendChild(renderer.domElement);

            createTreesPool();
            addWorld();
            addHero();
            addLight();
            addExplosion();

            camera.position.z = 6.5;
            camera.position.y = 3.5;

            orbitControl = new OrbitControls(camera, renderer.domElement);
            orbitControl.addEventListener("change", render);
            orbitControl.noKeys = true;
            orbitControl.noPan = true;
            orbitControl.autoRotate = true;
            orbitControl.enableZoom = false;
            orbitControl.minPolarAngle = 1.1;
            orbitControl.maxPolarAngle = 1.1;
            orbitControl.minAzimuthAngle = -0.2;
            orbitControl.maxAzimuthAngle = 0.2;

            window.addEventListener("resize", onWindowResize, false);

            scoreText = document.createElement("div");
            scoreText.id = "scoreText";
            scoreText.style.position = "absolute";
            scoreText.style.width = "300px";
            scoreText.style.height = "100px";
            scoreText.style.color = "#00ff00";
            scoreText.style.fontSize = "5em";
            scoreText.style.fontWeight = "bold";
            scoreText.innerHTML = "0";
            scoreText.style.top = "0px";
            scoreText.style.left = "20px";
            document.body.appendChild(scoreText);

            // Add "TOTAL TREE PASSED" text below score
            const scoreLabel = document.createElement("div");
            scoreLabel.id = "scoreLabel";
            scoreLabel.style.position = "absolute";
            scoreLabel.style.color = "#06680a";
            scoreLabel.style.fontSize = "1.2em";
            scoreLabel.style.fontWeight = "bold";
            scoreLabel.innerHTML = "TOTAL TREE PASSED";
            scoreLabel.style.top = "90px";
            scoreLabel.style.left = "20px";
            document.body.appendChild(scoreLabel);
        }

        function createSkullGeometry() {
            const skullGroup = new THREE.Group();

            // Main skull sphere
            const skullGeometry = new THREE.SphereGeometry(heroRadius, 12, 8);
            const skullMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5dc, 
                shading: THREE.FlatShading 
            });
            const skull = new THREE.Mesh(skullGeometry, skullMaterial);
            
            // Eye sockets
            const eyeGeometry = new THREE.SphereGeometry(heroRadius * 0.15, 6, 6);
            const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-heroRadius * 0.4, heroRadius * 0.2, heroRadius * 0.8);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(heroRadius * 0.4, heroRadius * 0.2, heroRadius * 0.8);

            // Nose cavity
            const noseGeometry = new THREE.ConeGeometry(heroRadius * 0.1, heroRadius * 0.3, 3);
            const noseMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, -heroRadius * 0.1, heroRadius * 0.8);
            nose.rotation.x = Math.PI;

            // Mouth
            const mouthGeometry = new THREE.PlaneGeometry(heroRadius * 0.6, heroRadius * 0.1);
            const mouthMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000, 
                side: THREE.DoubleSide 
            });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, -heroRadius * 0.6, heroRadius * 0.8);

            skullGroup.add(skull);
            skullGroup.add(leftEye);
            skullGroup.add(rightEye);
            skullGroup.add(nose);
            skullGroup.add(mouth);

            return skullGroup;
        }

        function addHero() {
            jumping = false;
            heroSphere = createSkullGeometry();
            heroSphere.receiveShadow = true;
            heroSphere.castShadow = true;
            scene.add(heroSphere);
            heroSphere.position.y = heroBaseY;
            heroSphere.position.z = 4.8;
            currentLane = middleLane;
            heroSphere.position.x = currentLane;
        }

        function addExplosion() {
            particleGeometry = new THREE.Geometry();
            for (var i = 0; i < particleCount; i++) {
                var vertex = new THREE.Vector3();
                particleGeometry.vertices.push(vertex);
            }
            var pMaterial = new THREE.ParticleBasicMaterial({ color: 0xfff8dc, size: 0.2 });
            particles = new THREE.Points(particleGeometry, pMaterial);
            scene.add(particles);
            particles.visible = false;
        }

        function createTreesPool() {
            var tree;
            for (var i = 0; i < 10; i++) {
                tree = createTree();
                treesPool.push(tree);
            }
        }

        var map = { 37: false, 39: false, 38: false };

        function addWorld() {
            var sides = 50;
            var tiers = 50;
            var sphereGeometry = new THREE.SphereGeometry(worldRadius, sides, tiers);
            var sphereMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x778000, 
                shading: THREE.FlatShading, 
                roughness: 1 
            });

            var vertexIndex;
            var vertexVector = new THREE.Vector3();
            var nextVertexVector = new THREE.Vector3();
            var firstVertexVector = new THREE.Vector3();
            var offset = new THREE.Vector3();
            var currentTier = 1;
            var lerpValue = 0.5;
            var heightValue;
            var maxHeight = 0.07;

            for (var j = 1; j < tiers - 1; j++) {
                currentTier = j;
                for (var i = 0; i < sides; i++) {
                    vertexIndex = (currentTier * sides) + 1;
                    vertexVector = sphereGeometry.vertices[i + vertexIndex].clone();

                    if (currentTier % 2 !== 0) {
                        if (i == 0) {
                            firstVertexVector = vertexVector.clone();
                        }
                        nextVertexVector = sphereGeometry.vertices[i + vertexIndex + 1].clone();
                        if (i == sides - 1) {
                            nextVertexVector = firstVertexVector;
                        }
                        lerpValue = (Math.random() * (0.75 - 0.25)) + 0.25;
                        vertexVector.lerp(nextVertexVector, lerpValue);
                    }
                    heightValue = (Math.random() * maxHeight) - (maxHeight / 2);
                    offset = vertexVector.clone().normalize().multiplyScalar(heightValue);
                    sphereGeometry.vertices[i + vertexIndex] = vertexVector.add(offset);
                }
            }

            rollingGroundSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            rollingGroundSphere.receiveShadow = true;
            rollingGroundSphere.castShadow = false;
            rollingGroundSphere.rotation.z = -Math.PI / 2;
            scene.add(rollingGroundSphere);
            rollingGroundSphere.position.y = -24;
            rollingGroundSphere.position.z = 2;
            addWorldTrees();
        }

        function addLight() {
            var hemisphereLight = new THREE.HemisphereLight(0xfffacd, 0x080820, 0.9);
            scene.add(hemisphereLight);
            sun = new THREE.DirectionalLight(0xcdcdcd, 0.9);
            sun.position.set(12, 6, -7);
            sun.castShadow = true;
            scene.add(sun);
            sun.shadow.mapSize.width = 256;
            sun.shadow.mapSize.height = 256;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 50;
        }

        function addPathTree() {
            var options = [0, 1, 2];
            var lane = Math.floor(Math.random() * 3);
            addTree(true, lane);
            options.splice(lane, 1);
            if (Math.random() > 0.5) {
                lane = Math.floor(Math.random() * 2);
                addTree(true, options[lane]);
            }
        }

        function addWorldTrees() {
            var numTrees = 36;
            var gap = 6.28 / 36;
            for (var i = 0; i < numTrees; i++) {
                addTree(false, i * gap, true);
                addTree(false, i * gap, false);
            }
        }

        function addTree(inPath, row, isLeft) {
            var newTree;
            if (inPath) {
                if (treesPool.length == 0) return;
                newTree = treesPool.pop();
                newTree.visible = true;
                treesInPath.push(newTree);
                sphericalHelper.set(worldRadius - 0.3, pathAngleValues[row], -rollingGroundSphere.rotation.x + 4);
            } else {
                newTree = createTree();
                var forestAreaAngle = 0;
                if (isLeft) {
                    forestAreaAngle = 1.68 + Math.random() * 0.1;
                } else {
                    forestAreaAngle = 1.46 - Math.random() * 0.1;
                }
                sphericalHelper.set(worldRadius - 0.3, forestAreaAngle, row);
            }
            newTree.position.setFromSpherical(sphericalHelper);
            var rollingGroundVector = rollingGroundSphere.position.clone().normalize();
            var treeVector = newTree.position.clone().normalize();
            newTree.quaternion.setFromUnitVectors(treeVector, rollingGroundVector);
            newTree.rotation.x += (Math.random() * (2 * Math.PI / 10)) + -Math.PI / 10;
            rollingGroundSphere.add(newTree);
        }

        function createTree() {
            var sides = 8;
            var tiers = 6;
            var scalarMultiplier = (Math.random() * (0.25 - 0.1)) + 0.05;
            var midPointVector = new THREE.Vector3();
            var vertexVector = new THREE.Vector3();
            var treeGeometry = new THREE.ConeGeometry(0.5, 1, sides, tiers);
            var treeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x33ff33, 
                shading: THREE.FlatShading 
            });
            var offset;
            midPointVector = treeGeometry.vertices[0].clone();
            var currentTier = 0;
            var vertexIndex;
            blowUpTree(treeGeometry.vertices, sides, 0, scalarMultiplier);
            tightenTree(treeGeometry.vertices, sides, 1);
            blowUpTree(treeGeometry.vertices, sides, 2, scalarMultiplier * 1.1, true);
            tightenTree(treeGeometry.vertices, sides, 3);
            blowUpTree(treeGeometry.vertices, sides, 4, scalarMultiplier * 1.2);
            tightenTree(treeGeometry.vertices, sides, 5);

            var tree = new THREE.Mesh(treeGeometry, treeMaterial);
            tree.castShadow = true;
            tree.receiveShadow = false;
            tree.position.y = 0.9;
            tree.rotation.y = Math.random() * Math.PI;

            var stumpGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5);
            var stumpMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x886633, 
                shading: THREE.FlatShading 
            });
            var stump = new THREE.Mesh(stumpGeometry, stumpMaterial);
            stump.position.y = 0.25;
            var treeGroup = new THREE.Object3D();
            treeGroup.add(stump);
            treeGroup.add(tree);
            return treeGroup;
        }

        function blowUpTree(vertices, sides, currentTier, scalarMultiplier, odd) {
            var vertexIndex;
            var vertexVector = new THREE.Vector3();
            var midPointVector = vertices[0].clone();
            var offset;
            for (var i = 0; i < sides; i++) {
                vertexIndex = (currentTier * sides) + 1;
                vertexVector = vertices[i + vertexIndex].clone();
                midPointVector.y = vertexVector.y;
                offset = vertexVector.sub(midPointVector);
                if (odd) {
                    if (i % 2 === 0) {
                        offset.normalize().multiplyScalar(scalarMultiplier / 6);
                        vertices[i + vertexIndex].add(offset);
                    } else {
                        offset.normalize().multiplyScalar(scalarMultiplier);
                        vertices[i + vertexIndex].add(offset);
                        vertices[i + vertexIndex].y = vertices[i + vertexIndex + sides].y + 0.05;
                    }
                } else {
                    if (i % 2 !== 0) {
                        offset.normalize().multiplyScalar(scalarMultiplier / 6);
                        vertices[i + vertexIndex].add(offset);
                    } else {
                        offset.normalize().multiplyScalar(scalarMultiplier);
                        vertices[i + vertexIndex].add(offset);
                        vertices[i + vertexIndex].y = vertices[i + vertexIndex + sides].y + 0.05;
                    }
                }
            }
        }

        function tightenTree(vertices, sides, currentTier) {
            var vertexIndex;
            var vertexVector = new THREE.Vector3();
            var midPointVector = vertices[0].clone();
            var offset;
            for (var i = 0; i < sides; i++) {
                vertexIndex = (currentTier * sides) + 1;
                vertexVector = vertices[i + vertexIndex].clone();
                midPointVector.y = vertexVector.y;
                offset = vertexVector.sub(midPointVector);
                offset.normalize().multiplyScalar(0.06);
                vertices[i + vertexIndex].sub(offset);
            }
        }

        function update() {
            if (!gameStarted) {
                render();
                requestAnimationFrame(update);
                return;
            }

            rollingSpeed += 0.000001;
            treeReleaseInterval -= 0.00001;
            rollingGroundSphere.rotation.x += rollingSpeed;
            heroSphere.rotation.x -= heroRollingSpeed;

            if (heroSphere.position.y <= heroBaseY) {
                jumping = false;
                bounceValue = (Math.random() * 0.04) + 0.005;
            }
            heroSphere.position.y += bounceValue;
            heroSphere.position.x = THREE.Math.lerp(heroSphere.position.x, currentLane, 2 * clock.getDelta());
            bounceValue -= gravity;

            if (clock.getElapsedTime() > treeReleaseInterval) {
                clock.start();
                addPathTree();
                if (!hasCollided) {
                    score += 2 * treeReleaseInterval;
                    score = Math.round(score);
                    scoreText.innerHTML = score.toString();
                }
            }
            doTreeLogic();
            doExplosionLogic();
            render();
            if (hasCollided) {
                // Stop background music when game over
                try {
                    if (backgroundMusic) {
                        backgroundMusic.pause();
                    }
                } catch (error) {
                    console.log("Error stopping audio:", error);
                }
                
                Swal.fire({
                    title: "üíÄ Game Over! üíÄ",
                    html: `
                        <div style="margin-bottom: 15px; font-size: 18px;">Score: ${score}</div>
                        <div style="margin-bottom: 10px; font-size: 14px; color: #06680a; font-weight: bold;">TOTAL TREE PASSED</div>
                        <div style="margin: 20px 0; padding: 10px; background: #333; border-radius: 5px;">
                            <div style="color: #fff; font-size: 14px; margin-bottom: 10px;">Advertisement</div>
                            <div style="width: 100%; height: 150px; background: linear-gradient(45deg, #5D5CDE, #7B7AFF); display: flex; align-items: center; justify-content: center; color: white; font-size: 16px; border-radius: 5px;">
                                Ads
                            </div>
                        </div>
                    `,
                    icon: "error",
                    showDenyButton: false,
                    showCancelButton: false,
                    confirmButtonText: "Try Again",
                    background: '#1a1a1a',
                    color: '#ffffff',
                    width: '90%',
                    maxWidth: '500px'
                }).then((result) => {
                    if (result.isConfirmed) {
                        location.reload();
                    }
                });
            } else {
                requestAnimationFrame(update);
            }
        }

        function doTreeLogic() {
            var oneTree;
            var treePos = new THREE.Vector3();
            var treesToRemove = [];
            treesInPath.forEach(function (element, index) {
                oneTree = treesInPath[index];
                treePos.setFromMatrixPosition(oneTree.matrixWorld);
                if (treePos.z > 6 && oneTree.visible) {
                    treesToRemove.push(oneTree);
                } else {
                    if (treePos.distanceTo(heroSphere.position) <= 0.6) {
                        explode();
                        hasCollided = true;
                    }
                }
            });
            var fromWhere;
            treesToRemove.forEach(function (element, index) {
                oneTree = treesToRemove[index];
                fromWhere = treesInPath.indexOf(oneTree);
                treesInPath.splice(fromWhere, 1);
                treesPool.push(oneTree);
                oneTree.visible = false;
            });
        }

        function doExplosionLogic() {
            if (!particles.visible) return;
            for (var i = 0; i < particleCount; i++) {
                particleGeometry.vertices[i].multiplyScalar(explosionPower);
            }
            if (explosionPower > 1.005) {
                explosionPower -= 0.001;
            } else {
                particles.visible = false;
            }
            particleGeometry.verticesNeedUpdate = true;
        }

        function explode() {
            particles.position.y = 2;
            particles.position.z = 4.8;
            particles.position.x = heroSphere.position.x;
            for (var i = 0; i < particleCount; i++) {
                var randomVertex = new THREE.Vector3();
                randomVertex.x = (Math.random() * 0.4) - 0.2;
                randomVertex.y = (Math.random() * 0.4) - 0.2;
                randomVertex.z = (Math.random() * 0.4) - 0.2;
                particleGeometry.vertices[i] = randomVertex;
            }
            explosionPower = 1.07;
            particles.visible = true;
        }

        function render() {
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            sceneHeight = window.innerHeight;
            sceneWidth = window.innerWidth;
            renderer.setSize(sceneWidth, sceneHeight);
            camera.aspect = sceneWidth / sceneHeight;
            camera.updateProjectionMatrix();
        }

        // Keyboard controls (for desktop)
        $(document).keydown(function (e) {
            if (!gameStarted) {
                startGame();
                return;
            }

            if (e.keyCode in map) {
                map[e.keyCode] = true;
                if (map[37]) {
                    handleMove('left');
                } else if (map[39]) {
                    handleMove('right');
                } else if (map[38]) {
                    handleMove('jump');
                }
            }
        }).keyup(function (e) {
            if (e.keyCode in map) {
                map[e.keyCode] = false;
            }
        });

        init();
    </script>

</body>
</html>